Ez a dokumentum egy **egyetemi el≈ëad√°s** anyaga az *oper√°ci√≥kutat√°s* t√°rgyhoz, amelyet **D√≥sa Gy√∂rgy** tartott a **Pannon Egyetem Matematika Tansz√©k√©n**. A c√≠me:

### **‚ÄûA k√©tf√°zis√∫ szimplex m√≥dszer (v√°zlatos bemutat√°sa)‚Äù**

A dokumentum c√©lja, hogy bemutassa a **k√©tf√°zis√∫ szimplex algoritmus** m≈±k√∂d√©s√©t egy konkr√©t **termel√©si probl√©ma** p√©ld√°j√°n kereszt√ºl.

---

### üìå F≈ë tartalmi elemek:

1. **Motiv√°ci√≥**:

   * Mi√©rt van sz√ºks√©g k√©t f√°zisra?
   * Mikor nem elegend≈ë az egyszer≈± szimplex m√≥dszer?

2. **Els≈ë f√°zis**:

   * Mesters√©ges v√°ltoz√≥k (pl. `y1`, `y2`) bevezet√©se.
   * Egy megengedett b√°zismegold√°s l√©trehoz√°sa mesters√©ges c√©lf√ºggv√©nnyel (`z' = -y1 - y2`).
   * Szimplex l√©p√©sek v√©grehajt√°sa, am√≠g nincs mesters√©ges v√°ltoz√≥ a b√°zisban.

3. **M√°sodik f√°zis**:

   * Visszat√©r√©s az eredeti c√©lf√ºggv√©nyhez.
   * √öj szimplex t√°bl√°zatok alapj√°n az **optim√°lis megold√°s** kisz√°m√≠t√°sa.

4. **Eredm√©ny √©rtelmez√©se**:

   * Mely term√©kekb≈ël mennyit gy√°rtsunk?
   * Mely er≈ëforr√°sokat haszn√°ljuk fel teljesen vagy r√©szben?
   * A maxim√°lis nyeres√©g (`z = 1570`).

---

### üìä P√©lda

Egy line√°ris programoz√°si modell, ahol:

* 5 term√©k (T1‚Ä¶T5),
* 3 er≈ëforr√°s korl√°t (`‚â•`, `‚â§`, `=`),
* Haszon: \[25, 28, 18, 40, 33].

Ez a p√©lda bemutatja az √°talak√≠t√°st standard form√°ra, a mesters√©ges v√°ltoz√≥k haszn√°lat√°t, majd a c√©lf√ºggv√©ny maxim√°l√°s√°t.

---

Szeretn√©d, hogy ezt a teljes anyagot √°talak√≠tsam jegyzet vagy markdown form√°tumba?




A k√©pen l√°that√≥ dia **‚ÄûA k√©tf√°zis√∫ szimplex m√≥dszer‚Äù** r√∂vid bemutat√°s√°t tartalmazza. √çme a tartalom **Markdown** form√°tumban az eredeti sz√∂veg meg≈ërz√©s√©vel:

---

## A k√©tf√°zis√∫ szimplex m√≥dszer

* Az els≈ë f√°zis feladata: megengedett b√°zismegold√°s el≈ë√°ll√≠t√°sa
* A m√°sodik f√°zis feladata: a megengedett b√°zismegold√°sb√≥l kiindulva, optim√°lis b√°zismegold√°s el≈ë√°ll√≠t√°sa
* Ha csupa ‚â§ felt√©tel van, √©s a jobboldalon csupa nemnegat√≠v sz√°m, akkor nincs sz√ºks√©g els≈ë f√°zisra, ilyen volt a kor√°bbi feladatunk. Egy√©bk√©nt viszont sz√ºks√©g lehet els≈ë f√°zisra.
* A k√©tf√°zis√∫ szimplex m√≥dszert egy feladat megold√°s√°n kereszt√ºl mutatjuk be (r√©szletesebben megtal√°lhat√≥ az aj√°nlott irodalomban).

---

Szeretn√©d az √∂sszes di√°hoz hasonl√≥ markdown konverzi√≥t?

Itt van a m√°sodik dia tartalma **Markdown** form√°tumban az eredeti st√≠lus meg≈ërz√©s√©vel:

---

## (Megint) egy termel√©si probl√©ma

Adott a k√∂vetkez≈ë t√°bl√°zat:

|            | T‚ÇÅ | T‚ÇÇ | T‚ÇÉ | T‚ÇÑ | T‚ÇÖ | K√©szlet | Felt√©tel t√≠pusa |
| ---------- | -- | -- | -- | -- | -- | ------- | --------------- |
| Er≈ëf‚ÇÅ      | 1  | 2  | 1  | 3  | 0  | 15      | ‚â•               |
| Er≈ëf‚ÇÇ      | 0  | 1  | 1  | 5  | 1  | 40      | ‚â§               |
| Er≈ëf‚ÇÉ      | 1  | 0  | 0  | 2  | 2  | 18      | =               |
| **Haszon** | 25 | 28 | 18 | 40 | 33 |         |                 |

**Magyar√°zat**:
Most az els≈ë er≈ëforr√°sb√≥l **legal√°bb 15**-√∂t, a m√°sodikb√≥l **legfeljebb 40**-et, a harmadikb√≥l **pontosan 18**-at kell felhaszn√°lni!

---

Szeretn√©d, hogy folytassam a k√∂vetkez≈ë di√°val?

Itt a harmadik dia tartalma **Markdown** form√°tumban:

---

## Ism√©t felmer√ºl≈ë k√©rd√©sek

Megint ezek a k√©rd√©sek mer√ºlnek fel, mint m√∫ltkor:
**Hogyan keress√ºnk optim√°lis megold√°st?**

* Van-e egy√°ltal√°n?
* Ha igen, akkor mennyi van?
* Hogyan tal√°ljuk meg?

> **De van m√©g egy fontos k√©rd√©s: *Hogyan induljunk*????**

---

J√∂het a k√∂vetkez≈ë dia is?

Itt van az 5. dia tartalma √°talak√≠tva **Markdown** form√°tumba:

---

## A feladat modellje

A k√∂vetkez≈ë t√°bl√°zat alapj√°n:

|            | T‚ÇÅ | T‚ÇÇ | T‚ÇÉ | T‚ÇÑ | T‚ÇÖ | K√©szlet | Felt√©tel t√≠pusa |
| ---------- | -- | -- | -- | -- | -- | ------- | --------------- |
| Er≈ëf‚ÇÅ      | 1  | 2  | 1  | 3  | 0  | 15      | ‚â•               |
| Er≈ëf‚ÇÇ      | 0  | 1  | 1  | 5  | 1  | 40      | ‚â§               |
| Er≈ëf‚ÇÉ      | 1  | 0  | 0  | 2  | 2  | 18      | =               |
| **Haszon** | 25 | 28 | 18 | 40 | 33 |         |                 |

A feladat matematikai modellje:

```
x‚ÇÅ + 2x‚ÇÇ + x‚ÇÉ + 3x‚ÇÑ       ‚â• 15  
     x‚ÇÇ + x‚ÇÉ + 5x‚ÇÑ + x‚ÇÖ   ‚â§ 40  
x‚ÇÅ       + 2x‚ÇÑ + 2x‚ÇÖ      = 18  

x·µ¢ ‚â• 0,   1 ‚â§ i ‚â§ 5  

Maximaliz√°land√≥:  
z = 25x‚ÇÅ + 28x‚ÇÇ + 18x‚ÇÉ + 40x‚ÇÑ + 33x‚ÇÖ ‚Üí max
```

---

J√∂het a 6. dia is?


Itt van a 6. dia tartalma **Markdown** form√°ban:

---

## Standard alakra hoz√°s ‚Äì els≈ë l√©p√©s

A modell:

```
x‚ÇÅ + 2x‚ÇÇ + x‚ÇÉ + 3x‚ÇÑ       ‚â• 15  
     x‚ÇÇ + x‚ÇÉ + 5x‚ÇÑ + x‚ÇÖ   ‚â§ 40  
x‚ÇÅ       + 2x‚ÇÑ + 2x‚ÇÖ      = 18  

x·µ¢ ‚â• 0,   1 ‚â§ i ‚â§ 5  
25x‚ÇÅ + 28x‚ÇÇ + 18x‚ÇÉ + 40x‚ÇÑ + 33x‚ÇÖ = z ‚Üí max
```

---

### √Åtalak√≠t√°s sztenderd alakra (marad√©k- √©s t√∂bbletv√°ltoz√≥kkal):

```
x‚ÇÅ + 2x‚ÇÇ + x‚ÇÉ + 3x‚ÇÑ - x‚ÇÜ            = 15  
     x‚ÇÇ + x‚ÇÉ + 5x‚ÇÑ + x‚ÇÖ + x‚Çá        = 40  
x‚ÇÅ       + 2x‚ÇÑ + 2x‚ÇÖ                = 18  

x·µ¢ ‚â• 0,   1 ‚â§ i ‚â§ 7  
25x‚ÇÅ + 28x‚ÇÇ + 18x‚ÇÉ + 40x‚ÇÑ + 33x‚ÇÖ = z ‚Üí max
```

**Ez a sztenderd alak.**

---

J√∂het a k√∂vetkez≈ë dia is?


Itt a 7. dia tartalma **Markdown** form√°tumban:

---

## Baj van! Nincs el√©g b√°zisvektorunk! H√°t akkor csin√°ljunk!

### √Åtalak√≠tott egyenletrendszer mesters√©ges v√°ltoz√≥kkal:

```
x‚ÇÅ + 2x‚ÇÇ + x‚ÇÉ + 3x‚ÇÑ ‚àí x‚ÇÜ + y‚ÇÅ        = 15  
     x‚ÇÇ + x‚ÇÉ + 5x‚ÇÑ + x‚ÇÖ + x‚Çá         = 40  
x‚ÇÅ       + 2x‚ÇÑ + 2x‚ÇÖ       + y‚ÇÇ      = 18  

x ‚â• 0,  y ‚â• 0  

25x‚ÇÅ + 28x‚ÇÇ + 18x‚ÇÉ + 40x‚ÇÑ + 33x‚ÇÖ = z ‚Üí max  
‚àíy‚ÇÅ ‚àí y‚ÇÇ = z* ‚Üí max
```

### Megjegyz√©sek:

* Az els≈ë (indul√≥) b√°zis ez lesz:
  **B = {q‚ÇÅ, a‚Çá, q‚ÇÇ}**,
  ahol az **x**-ek oszlopait `a`-val, az **y**-ok oszlopait `q`-val jel√∂lt√ºk *(mesters√©ges vektorok)*.

* Csakhogy az **y**-okat nem lenne szabad haszn√°lnunk!
  Akkor meg kell szabadulnunk t≈ël√ºk.

* Erre szolg√°l a **z**\* c√©lf√ºggv√©ny, amelyet **mesters√©ges** *(vagy m√°sodlagos)* c√©lf√ºggv√©nynek nevez√ºnk.

---

J√∂het a 8. dia is?





Itt van a 8. dia tartalma **Markdown** form√°tumban:

---

## K√∂vetkezik az **els≈ë f√°zis**

Ez addig tart, am√≠g van **q vektor** a b√°zisban.
*(Jelenleg kett≈ë is van.)*

### A kor√°bbi egyenletrendszer:

```
x‚ÇÅ + 2x‚ÇÇ + x‚ÇÉ + 3x‚ÇÑ ‚àí x‚ÇÜ + y‚ÇÅ        = 15  
     x‚ÇÇ + x‚ÇÉ + 5x‚ÇÑ + x‚ÇÖ + x‚Çá         = 40  
x‚ÇÅ       + 2x‚ÇÑ + 2x‚ÇÖ       + y‚ÇÇ      = 18  

x ‚â• 0,  y ‚â• 0  

25x‚ÇÅ + 28x‚ÇÇ + 18x‚ÇÉ + 40x‚ÇÑ + 33x‚ÇÖ = z ‚Üí max  
‚àíy‚ÇÅ ‚àí y‚ÇÇ = z* ‚Üí max
```

---

### Az els≈ë f√°zis **els≈ë szimplex t√°bl√°ja**:

| B  | x·¥Æ  | a‚ÇÅ  | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá | q‚ÇÅ | q‚ÇÇ |   |
| -- | --- | --- | -- | -- | -- | -- | -- | -- | -- | -- | - |
| ‚àí1 | q‚ÇÅ  | 15  | 1  | 2  | 1  | 3  | 0  | ‚àí1 | 0  | 1  | 0 |
| 0  | u‚Çá  | 40  | 0  | 1  | 1  | 5  | 1  | 0  | 1  | 0  | 0 |
| ‚àí1 | q‚ÇÇ  | 18  | 1  | 0  | 0  | 2  | 2  | 0  | 0  | 0  | 1 |
|    | z\* | ‚àí33 | ‚àí2 | ‚àí2 | ‚àí1 | ‚àí5 | ‚àí2 | 1  | 0  | 0  | 0 |

---

K√©szen √°llsz a 9. di√°ra is?










Itt a 9. dia tartalma **Markdown** form√°tumban:

---

## Hogyan kaptuk ezt meg?

| B  | x·¥Æ  | a‚ÇÅ  | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá | q‚ÇÅ | q‚ÇÇ |   |
| -- | --- | --- | -- | -- | -- | -- | -- | -- | -- | -- | - |
| ‚àí1 | q‚ÇÅ  | 15  | 1  | 2  | 1  | 3  | 0  | ‚àí1 | 0  | 1  | 0 |
| 0  | u‚Çá  | 40  | 0  | 1  | 1  | 5  | 1  | 0  | 1  | 0  | 0 |
| ‚àí1 | q‚ÇÇ  | 18  | 1  | 0  | 0  | 2  | 2  | 0  | 0  | 0  | 1 |
|    | z\* | ‚àí33 | ‚àí2 | ‚àí2 | ‚àí1 | ‚àí5 | ‚àí2 | 1  | 0  | 0  | 0 |

---

### Magyar√°zat:

* Baloldalon a **q vektorok** szorz√≥ja **‚àí1**, az **a vektoroknak** 0.
* A legals√≥ sorban: a **b√°zisvektorok alatt** 0 van.
* A t√∂bbi sz√°m a legals√≥ sorban: **skal√°rszorz√°ssal** k√©sz√ºlt.

**P√©ld√°k:**

* $-33 = (-1, 0, -1) \cdot (15, 40, 18)$
* $a_1$ alatt:
  $-2 = (-1, 0, -1) \cdot (1, 0, 1)$
* $a_4$ alatt:
  $-5 = (-1, 0, -1) \cdot (3, 5, 2)$

---

J√∂het a k√∂vetkez≈ë dia is?








Itt a 10. dia tartalma **Markdown** form√°ban:

---

## A Szimplex m√≥dszer **els≈ë f√°zisa**

* A szok√°sos m√≥don **b√°ziscser√©ket** v√©gz√ºnk.
* Fenntartjuk a b√°zismegold√°s **megengedetts√©g√©t**:
  **minimum szab√°ly**!!!
* A c√©lf√ºggv√©ny n√∂vekedjen (ha lehet), olyan oszlop megy a b√°zisba, ahol a **reduk√°lt k√∂lts√©g negat√≠v**.
* ‚Äû√ñr√ºl√ºnk‚Äù, ha **mesters√©ges vektor** megy ki a b√°zisb√≥l.
* Ha a c√©lf√ºggv√©ny m√°r **nem tud n√∂vekedni**, az akkor k√∂vetkezik be, ha a reduk√°lt k√∂lts√©g vektora **csupa nemnegat√≠v** sz√°mb√≥l √°ll ‚Äì ilyenkor **meg√°llunk**.

---

### √Åll√≠t√°s:

> Ha $z^*$ maxim√°lis √©rt√©ke negat√≠v (marad), akkor az *(eredeti)* feladatnak **nincs megengedett megold√°sa**.
> Ha viszont ‚Äûfelmegy‚Äù 0-ra, akkor az *(eredeti)* feladatnak **van megengedett megold√°sa**, √©s **√°tt√©r√ºnk a m√°sodik f√°zisra**.

---

J√∂het a 11. dia is?




Itt a 11. dia tartalma **Markdown** form√°ban:

---

## L√°ssuk a b√°ziscser√©ket

Kiindul√≥ t√°bla:

| B   | x·¥Æ  | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá | q‚ÇÅ | q‚ÇÇ |
| --- | --- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| q‚ÇÅ  | 15  | 1  | 2  | 1  | 3  | 0  | ‚àí1 | 0  | 1  | 0  |
| a‚Çá  | 40  | 0  | 1  | 1  | 5  | 1  | 0  | 1  | 0  | 0  |
| q‚ÇÇ  | 18  | 1  | 0  | 0  | 2  | 2  | 0  | 0  | 0  | 1  |
| z\* | ‚àí33 | ‚àí2 | ‚àí2 | ‚àí1 | ‚àí5 | ‚àí2 | 1  | 0  | 0  | 0  |

---

B√°ziscsere:
**q‚ÇÅ kiker√ºl a b√°zisb√≥l**, nem kell t√∂bb√©, az oszlop√°t t√∂r√∂lj√ºk.

Eredm√©ny√ºl kapott √∫j t√°bla:

| B   | x·¥Æ | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá | q‚ÇÇ |
| --- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| a‚ÇÅ  | 15 | 1  | 2  | 1  | 3  | 0  | ‚àí1 | 0  | 0  |
| a‚Çá  | 40 | 0  | 1  | 1  | 5  | 1  | 0  | 1  | 0  |
| q‚ÇÇ  | 3  | 0  | ‚àí2 | ‚àí1 | ‚àí1 | 2  | 1  | 0  | 1  |
| z\* | ‚àí3 | 0  | 2  | 1  | 1  | ‚àí2 | ‚àí1 | 0  | 0  |

---

J√∂het a 12. dia is?


Itt van a 12. dia tartalma **Markdown** form√°tumban:

---

## M√©g egy b√°ziscsere

### Kiindul√≥ t√°bla:

| B   | x·¥Æ | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá | q‚ÇÇ |
| --- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| a‚ÇÅ  | 15 | 1  | 2  | 1  | 3  | 0  | ‚àí1 | 0  | 0  |
| a‚Çá  | 40 | 0  | 1  | 1  | 5  | 1  | 0  | 1  | 0  |
| q‚ÇÇ  | 3  | 0  | ‚àí2 | ‚àí1 | ‚àí1 | 2  | 1  | 0  | 1  |
| z\* | ‚àí3 | 0  | 2  | 1  | 1  | ‚àí2 | ‚àí1 | 0  | 0  |

---

### B√°ziscsere eredm√©nye:

**q‚ÇÇ is kiker√ºl** a b√°zisb√≥l, oszlop√°t t√∂r√∂lj√ºk.

| B   | x·¥Æ | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá |
| --- | -- | -- | -- | -- | -- | -- | -- | -- |
| a‚ÇÅ  | 18 | 1  | 0  | 0  | 2  | 2  | 0  | 0  |
| a‚Çá  | 40 | 0  | 1  | 1  | 5  | 1  | 0  | 1  |
| a‚ÇÜ  | 3  | 0  | ‚àí2 | ‚àí1 | ‚àí1 | 2  | 1  | 0  |
| z\* | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |

---

### K√∂vetkeztet√©s:

L√°tjuk, hogy $z^*$ √©rt√©ke **felment 0-ra**,
ez az√©rt van, mert **nincs mesters√©ges vektor** a b√°zisban,
üëâ **v√©ge van az els≈ë f√°zisnak**.

---

J√∂het a 13. dia is?



Itt a 13. dia tartalma **Markdown** form√°tumban:

---

## Hogyan tov√°bb? *(M√°sodik f√°zis)*

### Itt tartunk:

| B   | x·¥Æ | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá |
| --- | -- | -- | -- | -- | -- | -- | -- | -- |
| a‚ÇÅ  | 18 | 1  | 0  | 0  | 2  | 2  | 0  | 0  |
| a‚Çá  | 40 | 0  | 1  | 1  | 5  | 1  | 0  | 1  |
| a‚ÇÜ  | 3  | 0  | ‚àí2 | ‚àí1 | ‚àí1 | 2  | 1  | 0  |
| z\* | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |

---

* Az als√≥ sorra (z\*) **m√°r nincs sz√ºks√©g**, helyette **visszat√©r√ºnk az igazi c√©lf√ºggv√©nyhez**.
* Az als√≥ sor sz√°mol√°sa **ism√©t skal√°rszorzattal** t√∂rt√©nik ‚Äî **vigy√°zni kell!**

---

### A c√©lf√ºggv√©ny egy√ºtthat√≥i:

```
25   28   18   40   33   0   0
```

### √öj t√°bla fejl√©ce alatt:

| B  | x·¥Æ | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá |   |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | - |
| 25 | a‚ÇÅ | 18 | 1  | 0  | 0  | 2  | 2  | 0  | 0 |
| 0  | a‚Çá | 40 | 0  | 1  | 1  | 5  | 1  | 0  | 1 |
| 0  | a‚ÇÜ | 3  | 0  | ‚àí2 | ‚àí1 | ‚àí1 | 2  | 1  | 0 |
| z  | ?  | ?  | ?  | ?  | ?  | ?  | ?  | ?  |   |

A `z` sor (az √∫j c√©lf√ºggv√©ny sor) √©rt√©keit most kell kisz√°m√≠tani skal√°rszorz√°ssal.

---

Sz√ºks√©ged van a `z` sor pontos kisz√°m√≠t√°s√°ra is?










Itt van a 14. dia tartalma **Markdown** form√°ban:

---

## Az als√≥ sor sz√°mol√°sa (skal√°rszorz√°ssal)

### C√©lf√ºggv√©ny egy√ºtthat√≥k:



### T√°bla:

|    |    |     | 25 | 28 |  18 |  40 | 33 |  0 |  0|
| -- | -- | --- | -- | --- | --- | -- | -- | -- | - |
|    | B  | x·¥Æ  | a‚ÇÅ  | a‚ÇÇ | a‚ÇÉ  | a‚ÇÑ  | a‚ÇÖ | a‚ÇÜ | a‚Çá |   
| -- | -- | --- | -- | --- | --- | -- | -- | -- | - |
| 25 | a‚ÇÅ | 18  | 1  | 0   | 0   | 2  | 2  | 0  | 0 |
| 0  | a‚Çá | 40  | 0  | 1   | 1   | 5  | 1  | 0  | 1 |
| 0  | a‚ÇÜ | 3   | 0  | ‚àí2  | ‚àí1  | ‚àí1 | 2  | 1  | 0 |
|    | z  | 450 | 0  | ‚àí28 | ‚àí18 | 10 | 17 | 0  | 0 |

---

### Sz√°m√≠t√°sok:

* P√©ld√°ul:
  $z = 25 \cdot 18 + 0 \cdot 40 + 0 \cdot 3 = 450$

* **DE!!!**
  Az als√≥ sor egyes elemeit nem csak sima skal√°rszorz√°ssal kapjuk, hanem:

  * Az adott oszlophoz tartoz√≥ c√©lf√ºggv√©ny egy√ºtthat√≥b√≥l **ki kell vonni** a skal√°rszorzat eredm√©ny√©t.

  * P√©ld√°ul **a‚ÇÇ alatt**:
    $-28 = 25 \cdot 0 + 0 \cdot 1 + 0 \cdot (-2) - 28$

  * Ugyan√≠gy **a‚ÇÑ alatt**:
    $10 = 25 \cdot 2 + 0 \cdot 5 + 0 \cdot (-1) - 40$

---

J√∂het a 15. dia is?



Itt van a 15. dia tartalma **Markdown** form√°ban:

---

## Innent≈ël ugyan√∫gy megy tov√°bb ‚Äì M√°sodik f√°zis v√©grehajt√°sa

### Ebb≈ël:

| B  | x·¥Æ  | a‚ÇÅ | a‚ÇÇ  | a‚ÇÉ  | a‚ÇÑ | a‚ÇÖ | a‚ÇÜ | a‚Çá |
| -- | --- | -- | --- | --- | -- | -- | -- | -- |
| a‚ÇÅ | 18  | 1  | 0   | 0   | 2  | 2  | 0  | 0  |
| a‚Çá | 40  | 0  | 1   | 1   | 5  | 1  | 0  | 1  |
| a‚ÇÜ | 3   | 0  | ‚àí2  | ‚àí1  | ‚àí1 | 2  | 1  | 0  |
| z  | 450 | 0  | ‚àí28 | ‚àí18 | 10 | 17 | 0  | 0  |

---

### Ez lett:

| B  | x·¥Æ   | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ  | a‚ÇÖ | a‚ÇÜ | a‚Çá |
| -- | ---- | -- | -- | -- | --- | -- | -- | -- |
| a‚ÇÅ | 18   | 1  | 0  | 0  | 2   | 2  | 0  | 0  |
| a‚ÇÇ | 40   | 0  | 1  | 1  | 5   | 1  | 0  | 1  |
| a‚ÇÜ | 83   | 0  | 0  | 1  | 9   | 4  | 1  | 2  |
| z  | 1570 | 0  | 0  | 10 | 150 | 45 | 0  | 28 |

---

‚úÖ **K√©sz is van a m√°sodik f√°zis is.**

Szeretn√©d, hogy az utols√≥ di√°t is √°tdolgozzam?




Itt van a 16. (utols√≥) dia tartalma **Markdown** form√°tumban:

---

## √ârt√©kelj√ºk ki a feladat megold√°s√°t

| B  | x·¥Æ   | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | a‚ÇÑ  | a‚ÇÖ | a‚ÇÜ | a‚Çá |
| -- | ---- | -- | -- | -- | --- | -- | -- | -- |
| a‚ÇÅ | 18   | 1  | 0  | 0  | 2   | 2  | 0  | 0  |
| a‚ÇÇ | 40   | 0  | 1  | 1  | 5   | 1  | 0  | 1  |
| a‚ÇÜ | 83   | 0  | 0  | 1  | 9   | 4  | 1  | 2  |
| z  | 1570 | 0  | 0  | 10 | 150 | 45 | 0  | 28 |

---

### Meg√°llap√≠t√°sok:

* ‚úÖ **Egyed√ºli optim√°lis megold√°st kaptunk!**

* Az optim√°lis megold√°s:

  $$
  x_{opt} = (18,\ 40,\ 0,\ 0,\ 0\ |\ 83,\ 0)
  $$

  Teh√°t:

  * az els≈ë term√©kb≈ël gy√°rtunk **18** egys√©get,
  * a m√°sodikb√≥l **40** egys√©get.

* Az els≈ë er≈ëforr√°s k√©szlet√©b≈ël:
  $x_6 = 83$-mal t√∂bbet haszn√°lunk fel, mint amennyit k√∂telez≈ë.

* A m√°sik k√©t er≈ëforr√°sb√≥l **pontosan annyit haszn√°lunk**, amennyi rendelkez√©sre √°ll.

* A c√©lf√ºggv√©ny √©rt√©ke: **1570**

---

Szeretn√©d, hogy az eg√©sz diasor markdown jegyzetk√©nt egy f√°jlba legyen rendezve?

# AIO

# A k√©tf√°zis√∫ szimplex m√≥dszer ‚Äì Jegyzet

## Dia 2 ‚Äì A k√©tf√°zis√∫ szimplex m√≥dszer

- Az els≈ë f√°zis feladata: megengedett b√°zismegold√°s el≈ë√°ll√≠t√°sa  
- A m√°sodik f√°zis feladata: a megengedett b√°zismegold√°sb√≥l kiindulva, optim√°lis b√°zismegold√°s el≈ë√°ll√≠t√°sa  
- Ha csupa ‚â§ felt√©tel van, √©s a jobboldalon csupa nemnegat√≠v sz√°m, akkor nincs sz√ºks√©g els≈ë f√°zisra, ilyen volt a kor√°bbi feladatunk. Egy√©bk√©nt viszont sz√ºks√©g lehet els≈ë f√°zisra.  
- A k√©tf√°zis√∫ szimplex m√≥dszert egy feladat megold√°s√°n kereszt√ºl mutatjuk be (r√©szletesebben megtal√°lhat√≥ az aj√°nlott irodalomban).

---

## Dia 3 ‚Äì (Megint) egy termel√©si probl√©ma

Adott a k√∂vetkez≈ë t√°bl√°zat:

|         | T‚ÇÅ | T‚ÇÇ | T‚ÇÉ | T‚ÇÑ | T‚ÇÖ | K√©szlet | Felt√©tel t√≠pusa |
|---------|----|----|----|----|----|---------|------------------|
| Er≈ëf‚ÇÅ   | 1  | 2  | 1  | 3  | 0  | 15      | ‚â•                |
| Er≈ëf‚ÇÇ   | 0  | 1  | 1  | 5  | 1  | 40      | ‚â§                |
| Er≈ëf‚ÇÉ   | 1  | 0  | 0  | 2  | 2  | 18      | =                |
| **Haszon** | 25 | 28 | 18 | 40 | 33 |         |                  |

**Magyar√°zat**:  
- az els≈ë er≈ëforr√°sb√≥l **legal√°bb 15**,  
- a m√°sodikb√≥l **legfeljebb 40**,  
- a harmadikb√≥l **pontosan 18** egys√©get kell felhaszn√°lni.

---

## Dia 4 ‚Äì K√©rd√©sek a megold√°shoz

- Van-e egy√°ltal√°n?
- Ha igen, akkor mennyi van?
- Hogyan tal√°ljuk meg?
- **Hogyan induljunk?**

---

## Dia 5 ‚Äì A modell matematikai alakja

```
x‚ÇÅ + 2x‚ÇÇ + x‚ÇÉ + 3x‚ÇÑ       ‚â• 15  
     x‚ÇÇ + x‚ÇÉ + 5x‚ÇÑ + x‚ÇÖ   ‚â§ 40  
x‚ÇÅ       + 2x‚ÇÑ + 2x‚ÇÖ      = 18  

x·µ¢ ‚â• 0,   1 ‚â§ i ‚â§ 5  

Maximaliz√°land√≥:  
z = 25x‚ÇÅ + 28x‚ÇÇ + 18x‚ÇÉ + 40x‚ÇÑ + 33x‚ÇÖ ‚Üí max
```

---

## Dia 6 ‚Äì √Åtalak√≠t√°s sztenderd alakra

```
x‚ÇÅ + 2x‚ÇÇ + x‚ÇÉ + 3x‚ÇÑ - x‚ÇÜ            = 15  
     x‚ÇÇ + x‚ÇÉ + 5x‚ÇÑ + x‚ÇÖ + x‚Çá        = 40  
x‚ÇÅ       + 2x‚ÇÑ + 2x‚ÇÖ                = 18  

x·µ¢ ‚â• 0,   1 ‚â§ i ‚â§ 7  
z = 25x‚ÇÅ + 28x‚ÇÇ + 18x‚ÇÉ + 40x‚ÇÑ + 33x‚ÇÖ ‚Üí max
```

---

## Dia 7 ‚Äì Mesters√©ges v√°ltoz√≥k bevezet√©se

```
x‚ÇÅ + 2x‚ÇÇ + x‚ÇÉ + 3x‚ÇÑ ‚àí x‚ÇÜ + y‚ÇÅ        = 15  
     x‚ÇÇ + x‚ÇÉ + 5x‚ÇÑ + x‚ÇÖ + x‚Çá         = 40  
x‚ÇÅ       + 2x‚ÇÑ + 2x‚ÇÖ       + y‚ÇÇ      = 18  

x ‚â• 0,  y ‚â• 0  

z* = ‚àíy‚ÇÅ ‚àí y‚ÇÇ ‚Üí max
```

---

## Dia 8‚Äì16 ‚Äì Szimplex t√°bla l√©p√©sek √©s megold√°s

L√©p√©senk√©nt v√©gigk√∂vetj√ºk a k√©tf√°zis√∫ szimplex m√≥dszer v√©grehajt√°s√°t b√°ziscser√©kkel, mesters√©ges v√°ltoz√≥k kivezet√©s√©vel, √©s v√©g√ºl az eredeti c√©lf√ºggv√©ny vissza√°ll√≠t√°s√°val.

### V√©gs≈ë eredm√©ny:

| x‚ÇÅ | x‚ÇÇ | x‚ÇÉ | x‚ÇÑ | x‚ÇÖ | x‚ÇÜ | x‚Çá |
|----|----|----|----|----|----|----|
| 18 | 40 |  0 |  0 |  0 | 83 |  0 |

- A c√©lf√ºggv√©ny √©rt√©ke: **z = 1570**
- Az els≈ë er≈ëforr√°sb√≥l **83-mal t√∂bbet** haszn√°lunk a sz√ºks√©gesn√©l.
- A m√°sik kett≈ëb≈ël pontosan annyit, amennyi el√©rhet≈ë.

---
 
 To implement a Python **solver from scratch** (i.e. **without using `scipy.optimize.linprog`**) for this linear programming problem using the **two-phase simplex method**, you'd need to build:

---

### üîß **High-Level Implementation Plan**

---

#### **1. Problem Representation**

Define the LP problem in standard form:

* Objective:
  Maximize $z = 25x_1 + 28x_2 + 18x_3 + 40x_4 + 33x_5$

* Subject to:

$$
\begin{aligned}
x_1 + 2x_2 + x_3 + 3x_4 &\ge 15 \\
x_2 + x_3 + 5x_4 + x_5 &\le 40 \\
x_1 + 2x_4 + 2x_5 &= 18 \\
x_i &\ge 0
\end{aligned}
$$

You must:

* Introduce **slack**, **surplus**, and **artificial** variables.
* Convert to standard form with equality constraints and an initial basic feasible solution (using Phase I).

---

#### **2. Phase I ‚Äì Find Feasible Starting Point**

* Add:

  * Surplus variable for constraint 1.
  * Slack variable for constraint 2.
  * Artificial variables where needed (e.g., constraint 1 and 3).
* Minimize artificial variable sum $z^* = y_1 + y_2$
* Use the **simplex algorithm** to drive artificial variables out of the basis.

---

#### **3. Phase II ‚Äì Optimize Original Objective**

* If $z^* = 0$, drop artificial variables and switch to original objective.
* Use **simplex tableau** iteration to find optimal value.

---

### üß† **Core Data Structures**

```python
tableau: np.ndarray   # simplex tableau
basic_vars: List[int] # indices of basic variables
non_basic_vars: List[int]
```

---

### ‚öôÔ∏è **Main Algorithm Structure**

```python
def two_phase_simplex(c, A, b, constraint_types):
    # Phase I: Build tableau with artificial variables
    tableau, basic_vars = build_phase_one_tableau(A, b, constraint_types)
    run_simplex(tableau, basic_vars, phase=1)

    # Check feasibility
    if tableau[-1, -1] > 1e-8:
        raise Exception("Infeasible")

    # Phase II: Build original tableau without artificial vars
    tableau, basic_vars = build_phase_two_tableau(tableau, basic_vars, c)
    run_simplex(tableau, basic_vars, phase=2)

    return extract_solution(tableau, basic_vars)
```

---

### üîÅ **Simplex Iteration**

```python
def run_simplex(tableau, basic_vars, phase):
    while True:
        pivot_col = select_entering_variable(tableau)
        if pivot_col is None:  # optimal
            break

        pivot_row = select_leaving_variable(tableau, pivot_col)
        if pivot_row is None:
            raise Exception("Unbounded")

        pivot(tableau, pivot_row, pivot_col)
        basic_vars[pivot_row] = pivot_col
```

---

### üßÆ **Pivoting Logic**

```python
def pivot(tableau, row, col):
    tableau[row] /= tableau[row, col]
    for r in range(len(tableau)):
        if r != row:
            tableau[r] -= tableau[r, col] * tableau[row]
```

---

### ‚úÖ Output

At the end, return:

```python
{
  'x_opt': [...],
  'z_opt': ...,
  'status': 'optimal'
}
```

---

### ‚ö†Ô∏è Key Challenges

* Properly manage artificial variables.
* Row operations must maintain numerical stability.
* Correctly extract variable values from the final tableau.

---

Would you like me to **implement this solver** step-by-step for this specific problem?

To implement the solver for the **two-phase simplex method** as detailed in the uploaded document, we will:

1. Set up the simplex tableau.
2. Implement Phase I to eliminate artificial variables.
3. Switch to the original objective function and perform Phase II.
4. Output the final solution.

Here is a **C++ implementation** based on the data from the lecture example:

---

### ‚úÖ `two_phase_simplex.cpp`

```cpp
#include <iostream>
#include <vector>
#include <iomanip>

using namespace std;

const int VARS = 5;     // x1..x5
const int SLACK = 2;    // x6 (surplus), x7 (slack)
const int ARTIFICIAL = 2; // y1, y2

const int COLS = VARS + SLACK + ARTIFICIAL; // total variables
const int ROWS = 3; // number of constraints

typedef vector<vector<double>> Matrix;

void printTableau(const Matrix& tableau, const vector<int>& basis) {
    cout << "Tableau:\n";
    for (int i = 0; i < tableau.size(); ++i) {
        if (i < basis.size())
            cout << "x" << basis[i] + 1 << "\t";
        else
            cout << " z\t";
        for (double val : tableau[i]) {
            cout << setw(7) << val << " ";
        }
        cout << endl;
    }
    cout << endl;
}

int findEnteringVariable(const vector<double>& costRow) {
    int pos = -1;
    double minVal = 1e-9;
    for (int j = 0; j < costRow.size(); ++j) {
        if (costRow[j] < minVal) {
            minVal = costRow[j];
            pos = j;
        }
    }
    return pos;
}

int findLeavingVariable(const Matrix& tableau, int pivotCol, const vector<int>& basis) {
    double minRatio = 1e9;
    int pivotRow = -1;
    for (int i = 0; i < ROWS; ++i) {
        double val = tableau[i][pivotCol];
        if (val > 1e-9) {
            double ratio = tableau[i].back() / val;
            if (ratio < minRatio) {
                minRatio = ratio;
                pivotRow = i;
            }
        }
    }
    return pivotRow;
}

void pivot(Matrix& tableau, vector<int>& basis, int pivotRow, int pivotCol) {
    double pivotElement = tableau[pivotRow][pivotCol];

    // Normalize pivot row
    for (double& x : tableau[pivotRow]) {
        x /= pivotElement;
    }

    // Eliminate pivot column in other rows
    for (int i = 0; i < tableau.size(); ++i) {
        if (i == pivotRow) continue;
        double ratio = tableau[i][pivotCol];
        for (int j = 0; j < tableau[i].size(); ++j) {
            tableau[i][j] -= ratio * tableau[pivotRow][j];
        }
    }

    basis[pivotRow] = pivotCol;
}

void simplex(Matrix& tableau, vector<int>& basis) {
    while (true) {
        int entering = findEnteringVariable(tableau.back());
        if (entering == -1) break;
        int leaving = findLeavingVariable(tableau, entering, basis);
        if (leaving == -1) {
            cout << "Unbounded!\n";
            return;
        }
        pivot(tableau, basis, leaving, entering);
        printTableau(tableau, basis);
    }
}

int main() {
    // Initial tableau for Phase I (3 constraints, 9 variables + RHS)
    Matrix tableau = {
        {1, 2, 1, 3, 0, -1, 0, 1, 0, 15},   // x1..x5, x6,x7,y1,y2, RHS
        {0, 1, 1, 5, 1,  0, 1, 0, 0, 40},
        {1, 0, 0, 2, 2,  0, 0, 0, 1, 18},
        {-1, -2, -2, -1, -5, 1, 0, -1, -1, -33} // Artificial objective (Phase I)
    };

    vector<int> basis = {7, 6, 8}; // q1 (y1), x7, q2 (y2)

    cout << "== Phase I ==\n";
    printTableau(tableau, basis);
    simplex(tableau, basis);

    // Remove artificial variables (y1, y2) from tableau and objective
    for (auto& row : tableau) {
        row.erase(row.begin() + 7, row.begin() + 9); // erase y1, y2
    }

    // Replace z' row with real objective coefficients (25,28,18,40,33,0,0)
    tableau.back() = {25, 28, 18, 40, 33, 0, 0, 0};

    // Update z row using current basis
    for (int j = 0; j < COLS - ARTIFICIAL; ++j) {
        double sum = 0;
        for (int i = 0; i < ROWS; ++i) {
            sum += tableau[i][j] * tableau.back()[basis[i]];
        }
        tableau.back()[j] -= sum;
    }

    // Compute new z value
    double zVal = 0;
    for (int i = 0; i < ROWS; ++i)
        zVal += tableau[i].back() * tableau.back()[basis[i]];
    tableau.back().back() = zVal;

    cout << "== Phase II ==\n";
    printTableau(tableau, basis);
    simplex(tableau, basis);

    cout << "== Optimal Solution ==\n";
    vector<double> solution(COLS - ARTIFICIAL, 0);
    for (int i = 0; i < ROWS; ++i) {
        if (basis[i] < solution.size())
            solution[basis[i]] = tableau[i].back();
    }
    for (int i = 0; i < VARS; ++i) {
        cout << "x" << i + 1 << " = " << solution[i] << endl;
    }
    cout << "z = " << tableau.back().back() << endl;

    return 0;
}
```

---

### üõ†Ô∏è Compilation

Use a C++11 (or later) compiler:

```bash
g++ -std=c++11 -o simplex_solver two_phase_simplex.cpp
./simplex_solver
```

Would you like me to refactor this into separate header and source files or add file input support?

# cpp

```cpp
// two_phase_simplex.cpp
#include "two_phase_simplex.h"
#include <iostream>
#include <fstream>
#include <iomanip>

using namespace std;

void printTableau(const Matrix& tableau, const vector<int>& basis) {
    cout << "Tableau:\n";
    for (int i = 0; i < tableau.size(); ++i) {
        if (i < basis.size())
            cout << "x" << basis[i] + 1 << "\t";
        else
            cout << " z\t";
        for (double val : tableau[i]) {
            cout << setw(7) << val << " ";
        }
        cout << endl;
    }
    cout << endl;
}

int findEnteringVariable(const vector<double>& costRow) {
    int pos = -1;
    double minVal = 1e-9;
    for (int j = 0; j < costRow.size(); ++j) {
        if (costRow[j] < minVal) {
            minVal = costRow[j];
            pos = j;
        }
    }
    return pos;
}

int findLeavingVariable(const Matrix& tableau, int pivotCol, const vector<int>& basis) {
    double minRatio = 1e9;
    int pivotRow = -1;
    for (int i = 0; i < tableau.size() - 1; ++i) {
        double val = tableau[i][pivotCol];
        if (val > 1e-9) {
            double ratio = tableau[i].back() / val;
            if (ratio < minRatio) {
                minRatio = ratio;
                pivotRow = i;
            }
        }
    }
    return pivotRow;
}

void pivot(Matrix& tableau, vector<int>& basis, int pivotRow, int pivotCol) {
    double pivotElement = tableau[pivotRow][pivotCol];
    for (double& x : tableau[pivotRow]) {
        x /= pivotElement;
    }
    for (int i = 0; i < tableau.size(); ++i) {
        if (i == pivotRow) continue;
        double ratio = tableau[i][pivotCol];
        for (int j = 0; j < tableau[i].size(); ++j) {
            tableau[i][j] -= ratio * tableau[pivotRow][j];
        }
    }
    basis[pivotRow] = pivotCol;
}

void simplex(Matrix& tableau, vector<int>& basis) {
    while (true) {
        int entering = findEnteringVariable(tableau.back());
        if (entering == -1) break;
        int leaving = findLeavingVariable(tableau, entering, basis);
        if (leaving == -1) {
            cout << "Unbounded!\n";
            return;
        }
        pivot(tableau, basis, leaving, entering);
        printTableau(tableau, basis);
    }
}

void solveFromFile(const string& filename) {
    // Implement file input handling as needed
    // This example uses a fixed model based on the uploaded PDF

    const int VARS = 5, SLACK = 2, ARTIFICIAL = 2;
    const int COLS = VARS + SLACK + ARTIFICIAL;
    const int ROWS = 3;

    Matrix tableau = {
        {1, 2, 1, 3, 0, -1, 0, 1, 0, 15},
        {0, 1, 1, 5, 1,  0, 1, 0, 0, 40},
        {1, 0, 0, 2, 2,  0, 0, 0, 1, 18},
        {-1, -2, -2, -1, -5, 1, 0, -1, -1, -33}
    };

    vector<int> basis = {7, 6, 8};

    cout << "== Phase I ==\n";
    printTableau(tableau, basis);
    simplex(tableau, basis);

    for (auto& row : tableau) {
        row.erase(row.begin() + 7, row.begin() + 9);
    }

    tableau.back() = {25, 28, 18, 40, 33, 0, 0, 0};
    for (int j = 0; j < COLS - ARTIFICIAL; ++j) {
        double sum = 0;
        for (int i = 0; i < ROWS; ++i) {
            sum += tableau[i][j] * tableau.back()[basis[i]];
        }
        tableau.back()[j] -= sum;
    }

    double zVal = 0;
    for (int i = 0; i < ROWS; ++i)
        zVal += tableau[i].back() * tableau.back()[basis[i]];
    tableau.back().back() = zVal;

    cout << "== Phase II ==\n";
    printTableau(tableau, basis);
    simplex(tableau, basis);

    cout << "== Optimal Solution ==\n";
    vector<double> solution(COLS - ARTIFICIAL, 0);
    for (int i = 0; i < ROWS; ++i) {
        if (basis[i] < solution.size())
            solution[basis[i]] = tableau[i].back();
    }
    for (int i = 0; i < VARS; ++i) {
        cout << "x" << i + 1 << " = " << solution[i] << endl;
    }
    cout << "z = " << tableau.back().back() << endl;
}
```
# h

```cpp
// two_phase_simplex.h
#ifndef TWO_PHASE_SIMPLEX_H
#define TWO_PHASE_SIMPLEX_H

#include <vector>

using Matrix = std::vector<std::vector<double>>;

void printTableau(const Matrix& tableau, const std::vector<int>& basis);
int findEnteringVariable(const std::vector<double>& costRow);
int findLeavingVariable(const Matrix& tableau, int pivotCol, const std::vector<int>& basis);
void pivot(Matrix& tableau, std::vector<int>& basis, int pivotRow, int pivotCol);
void simplex(Matrix& tableau, std::vector<int>& basis);
void solveFromFile(const std::string& filename);

#endif // TWO_PHASE_SIMPLEX_H
```